import{g as e,d as t,y as s}from"./index-0094ed61.js";import{m as n,p as a,n as r,I as i,u as c}from"./firebase-147eafc7.js";import"./vendor-ea3cc270.js";import"./i18n-80c88d68.js";import"./ui-a8f8a709.js";class SyncManager{constructor(){this.syncInProgress=!1,this.syncInterval=null,this.onlineStatus=navigator.onLine,this.startNetworkMonitoring(),this.startAutoSync()}static getInstance(){return SyncManager.instance||(SyncManager.instance=new SyncManager),SyncManager.instance}startNetworkMonitoring(){window.addEventListener("online",()=>{this.onlineStatus=!0,this.triggerAutoSync()}),window.addEventListener("offline",()=>{this.onlineStatus=!1})}startAutoSync(){this.syncInterval=setInterval(()=>{this.triggerAutoSync()},3e5)}async triggerAutoSync(){var t,s;if(this.onlineStatus&&!this.syncInProgress)try{const n=await e.listLocalProfiles();for(const e of n)if("firebase"===(null==(t=e.owner)?void 0:t.source)||(null==(s=e.owner)?void 0:s.uid)){const t=await this.getSyncPreferences(e.id);t.autoSync&&!t.manualOnly&&await this.syncProfile(e.id)}}catch(n){}}async getSyncPreferences(t){return(await e.getLocalProfileData(t)).syncPreferences||{autoSync:!0,manualOnly:!1,selectedCategories:["profile","services","trustVerification"],lastSync:null,syncStatus:"idle",pendingChanges:0}}async updateSyncPreferences(t,s){const n=await e.getLocalProfileData(t),a={...n,syncPreferences:{...n.syncPreferences,...s}};await e.updateLocalProfileData(t,a)}async manualSync(e){return this.syncInProgress?{success:!1,conflicts:[],syncedCategories:[],error:"Sync already in progress"}:await this.syncProfile(e)}async syncProfile(c){if(!t.currentUser)return{success:!1,conflicts:[],syncedCategories:[],error:"Not authenticated with Firebase"};this.syncInProgress=!0;const o={success:!1,conflicts:[],syncedCategories:[]};try{await this.updateSyncPreferences(c,{syncStatus:"syncing"});const l=await this.getSyncPreferences(c),y=await e.getLocalProfileData(c),f=n(s,"users",t.currentUser.uid),d=await a(f);if(d.exists()){const e=d.data(),t=[];for(const s of l.selectedCategories){const n=y[s],a=e[s];this.hasConflict(n,a)?t.push({field:s,localValue:n,remoteValue:a,resolved:!1}):(await this.syncCategory(f,s,n,a,y,e),o.syncedCategories.push(s))}o.conflicts=t,o.success=0===t.length}else await r(f,{profile:y.profile||{},services:y.services||[],trustVerification:y.trustVerification||{},lastSync:i(),syncedCategories:l.selectedCategories}),o.success=!0,o.syncedCategories=l.selectedCategories;await this.updateSyncPreferences(c,{lastSync:Date.now(),syncStatus:o.success?"success":"error",pendingChanges:o.success?0:l.pendingChanges})}catch(l){o.error=l instanceof Error?l.message:"Unknown sync error",await this.updateSyncPreferences(c,{syncStatus:"error"})}finally{this.syncInProgress=!1}return o}hasConflict(e,t){return!(!e&&!t)&&(!e||!t||("object"!=typeof e||"object"!=typeof t?e!==t:JSON.stringify(e)!==JSON.stringify(t)))}async syncCategory(t,s,n,a,r,o){var l,y;if(((null==(l=r.lastModified)?void 0:l[s])||0)>((null==(y=o.lastModified)?void 0:y[s])||0))await c(t,{[s]:n,[`lastModified.${s}`]:Date.now(),lastSync:i()});else{const t={...r,[s]:a,lastModified:{...r.lastModified,[s]:Date.now()}};await e.updateLocalProfileData(r.profileId,t)}}async resolveConflicts(r,o){const l=await e.getLocalProfileData(r);if(await this.getSyncPreferences(r),!t.currentUser)return;const y=n(s,"users",t.currentUser.uid),f=await a(y);if(!f.exists())return;const d=f.data(),g={lastSync:i()};for(const[t,s]of Object.entries(o)){switch(s){case"local":g[t]=l[t];break;case"remote":const s={...l,[t]:d[t],lastModified:{...l.lastModified,[t]:Date.now()}};await e.updateLocalProfileData(r,s);break;case"merge":const n=this.mergeValues(l[t],d[t]);g[t]=n;const a={...l,[t]:n,lastModified:{...l.lastModified,[t]:Date.now()}};await e.updateLocalProfileData(r,a)}g[`lastModified.${t}`]=Date.now()}await c(y,g)}mergeValues(e,t){return Array.isArray(e)&&Array.isArray(t)?[...new Set([...e,...t])]:"object"==typeof e&&"object"==typeof t?{...t,...e}:e}async incrementPendingChanges(e){const t=await this.getSyncPreferences(e);await this.updateSyncPreferences(e,{pendingChanges:t.pendingChanges+1})}async resetPendingChanges(e){await this.updateSyncPreferences(e,{pendingChanges:0})}async getPendingChanges(e){return(await this.getSyncPreferences(e)).pendingChanges}}const o=SyncManager.getInstance();export{o as syncManager};
